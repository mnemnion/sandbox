# Introduction to the Martian Stack: What it Is, Why You Should Care

The first question is easy to answer: the Martian Stack is my nickname for [Urbit](http://moronlab.blogspot.com/), which was, for awhile there, the only English on the subject. Typical of the author, he opened up a [github](https://github.com/cgyarvin), without further comment or explanation. He's busy, you see; let's not bother him. 

There's apparently a list somewhere, and I'm not on it. By rumour, he's not exactly being forthcoming on the list either. 

This level of firm isolation from the body public is unusual in an open source effort. The entire thing is cryptic, if rich in metaphor. One is reminded of early mathematics, wherein the true significance of a finding was often deeply buried, the idea being to get later credit for the discovery without arming your competitors with the knowledge gained. 

In this foray, I will have little to say about Urbit, proper. Understanding Urbit requires understandong Hoon, and I do not. To understand Hoon, you must first understand Nock, which I do, somewhat. That's why I'm writing this, actually, because if I can explain Nock, I understand it well enough to make progress with Hoon. 

## A Brief Background (Mine)

Let me briefly answer the meta-question: Why should I, the reader, care what you, the author, have to say? 

You might, you might not. I am, at best, a hacker; my degree, such as it is, is in chemistry. I am a particular kind of hacker: [Yogacara](http://en.wikipedia.org/wiki/Yogacara) perhaps, almost Neoplatonist, certainly Hermetic. 

I came by this the honest way, through obsession throughout puberty. Basic gave way to Turbo Pascal, which was a heady, almost uncontrollable power. Then there was Delphi. The seams were beginning to show. Two lateral moves in a row, to C++ and Java, provided the requisite grounding in braces and pointer dereferencing, with a side effect of thorough disgust and confusion. To this day, gazing at a graphical representation of a classes exposed methods causes my eye to twitch. 

I had heard of Lisp, and Smalltalk, and the like. Somehow they never ended up on my Yggdrasil partition. Dragon book, yes, a thousand times yes; SICP, no. K&R, read, appreciated, only thinly applied. 

In any case, by the time I reached university (and there were adventures along the way) I settled on chem as likely to be the discipline that would explain, on the right level of detail, exactly how the universe worked. This was a good choice, incidentally, although the job prospects are either a species of serfdom or further education. 

University was where I began a pattern of trying, and mostly failing, to be paid for anything but programming computers. My first student job was running perl scripts to munge together a bunch of bioinformatics simulations on Solaris. Perl was actually ok; inscrutable, but the Camel contained all wisdom, and recipes were numerous. 

Then I wandered across the hall to the Biology department, bluffed my way into genetics, and started working for the prof. The deal was he'd teach me wetwork if I did the computer stuff for his own high-concept bioinformatics project. 

The bioinformatics project was fundamentally about calculating the syntropy of nodes in heterogenous graphs; the paper had roughly fifteen names when it collapsed beneath its own weight. The wetwork involved sticking jellyfish DNA into plants, and succeeded. 

I'll skip ahead: After numerous adventures, I'm taking money to program computers again. Half days, I work on an EBNF grammar, the others, I write OpenCL kernels. The middle layer is Java; I try not to touch it, and when I do, I use Clojure whenever possible. 

## Back to the Topic At Hand



